'''define kernel and use convolution with kernel instead of counting neighboursmake the Kernel into a class to define different instancese.g. circular, square etc'''#import useful librariesimport numpy as np#define gaussian curve function - used to make smooth kernels with gradual fadebell = lambda x, mean, std: np.exp(-((x-mean)/std)**2 / 2)class Kernel:    '''define normalised convolution kernel    allows generalisation rather than counting neighbours'''    global bell        def __init__(self, size, kernel_type='square', smooth=False, R=None, end=False):                '''kernel described as a 2D array'''                if kernel_type == 'square':            #create a square kernel            self.K = np.ones((2*R+1, 2*R+1))            self.K[R, R] = 0  # centre pixel            self.K_sum = np.sum(self.K)  # maximum value of the convolution            self.K = self.K / self.K_sum  # normalise the kernel            if end: #make kernel same size as world grid                pad = (size - (2*R+1)) //2                if size%2 == 0:                    self.K = np.pad(self.K, ((pad, pad+1), (pad, pad+1)), mode='constant')                else:                    self.K = np.pad(self.K, ((pad, pad), (pad, pad)), mode='constant')                    elif kernel_type == 'circular':            #create a circular kernel            if end:                 #kernel same size as world grid                mid = size//2                x = np.arange(-mid, mid)                y = np.arange(-mid, mid)            else:                x = np.arange(-R,R+1)                y = np.arange(-R,R+1)            X, Y = np.meshgrid(x, y)            center = np.array([0,0])            #check if distance from centre is less than specified radius            distance = np.linalg.norm(np.stack((X,Y),axis=-1)-center,axis=-1)/R            #give value to             if smooth:                self.K = (distance<=1.0) * bell(distance,0.5,0.15)            else:                self.K = (distance<=1.0)                self.K[R, R] = 0  # centre pixel                                        self.K_sum = np.sum(self.K)  # maximum value of the convolution            self.K = self.K / self.K_sum  # normalise the kernel    def growth(self, U, m=0.15, s=0.015):                '''define the associated growth function'''                '''tophat:        condition_alive = (U >= 0.12) & (U <= 0.15)        condition_dead = (U < 0.12) | (U > 0.15)        return np.where(condition_alive, 1, np.where(condition_dead, -1, 0))'''                '''continuous'''        return bell(U, m, s)*2 - 1 #gaussian range(0,1) adjust st (-1,1)