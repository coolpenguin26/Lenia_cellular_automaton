'''update functions used for GoL and for Lenia'''#import useful librariesimport numpy as npimport scipy.signal#GAME OF LIFEdef update_gol(A):    '''advances GoL world by one time step    applies to every element in the array    counts the number of Moore neighbours    uses Conway's rules to determine the state in next time step'''        #call the world grid    #global img    '''U is the neighbour sums    counts 8 nearest Moore neigbours - if statement excludes counting cell itself    np roll deals with periodic boundary conditions, equivalent to toroidal arrangement of 2D space'''            U = sum(np.roll(A,(i,j),axis=(0,1)) for i in (-1,0,+1) for j in (-1,0,+1) if (i!=0 or j!=0))    '''update cell value according to rules    if cell is alive and U = 2, the cell continues alive (value 1)    if cell is dead or alive and U = 3, the cell lives (value 1)    all other cases cell dies (value 0)'''        A = (A & (U==2)) | (U==3)        #img.set_array(A) #visual representation of array    #return img        return A#LENIAdef update(A,kernel,convolution_FFT=False,fK=None,T=10):    '''advances the Lenia world by one time step    applies to every element in the array    convolves array with the kernel    then uses result in growth rule'''        #U is the neighbour sums        if convolution_FFT:        '''FFT to perform convolution'''        U = np.real(np.fft.ifft2(fK * np.fft.fft2(A)))    else:        '''scipy convolution function        same mode gives output same size as A        wrap boundary gives circular boundary conditions'''        U = scipy.signal.convolve2d(A,kernel.K,mode='same',boundary='wrap')    '''scale down incremental updates by factor of dt=1/T    taking T to infinity i.e. very small time steps, is continuous time'''    A = np.clip(A + 1/T * kernel.growth(U), 0, 1)    #img.set_array(A) #visual representation of array    #return img    return A